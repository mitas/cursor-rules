---
description: PHPUnit testing best practices for PHP applications
globs: "**/*Test.php"
alwaysApply: false
parent_file: php.mdc
---

# PHPUnit Testing Best Practices

## Context

- PHPUnit is the de facto standard for testing PHP applications
- Well-structured tests improve code quality and prevent regressions
- Tests should be readable, maintainable, and follow consistent patterns
- Modern PHP code should leverage type hints, return types, and other language features

## Version Detection

- First, automatically determine PHP and PHPUnit versions from the project's composer.json:
  ```php
  // Function to extract version constraints from composer.json
  function getVersionsFromComposer() {
      $composerPath = __DIR__ . '/composer.json';
      // Try looking up the directory tree for composer.json
      for ($i = 0; $i < 5 && !file_exists($composerPath); $i++) {
          $composerPath = dirname(__DIR__, $i+1) . '/composer.json';
      }
      
      if (!file_exists($composerPath)) {
          return ['php' => '>=7.2', 'phpunit' => '^6.0']; // Default fallback
      }
      
      $composer = json_decode(file_get_contents($composerPath), true);
      $phpVersion = $composer['require']['php'] ?? '>=7.2';
      $phpunitVersion = $composer['require-dev']['phpunit/phpunit'] ?? '^6.0';
      
      return ['php' => $phpVersion, 'phpunit' => $phpunitVersion];
  }
  
  $versions = getVersionsFromComposer();
  ```
- Adjust test syntax and features based on detected PHP and PHPUnit versions
- For PHPUnit 6.x (detected in your project):
  - Use namespaced class names (\PHPUnit\Framework\TestCase)
  - Use expectException() instead of setExpectedException()
  - Use type hints where supported by your PHP version

## Critical rules

- Use namespaces that match the directory structure of the code being tested
- Write test classes that extend \PHPUnit\Framework\TestCase
- Use descriptive test class names that end with "Test"
- Use descriptive test method names that clearly explain what is being tested
- Prefix test methods with "test" or use @test annotation
- Test methods should have void return type (for PHP 7.1+)
- Use setUp() and tearDown() methods for common initialization and cleanup
- Test one thing per test method
- Use assertions appropriate for the data type being tested
- Follow Arrange-Act-Assert (AAA) pattern for test structure:
  - **Arrange**: Set up the test data and dependencies
  - **Act**: Perform the action being tested
  - **Assert**: Verify the expected outcome
- Use test doubles (mocks, stubs, spies) when appropriate for isolation
- Keep tests independent and isolated from each other

## Mocking Strategies

- Use dependency injection to make code testable
- Create mocks with the appropriate PHPUnit version syntax:
  - For PHPUnit 6+: `$this->createMock(ClassToMock::class)`
- Set up mock method expectations clearly:
  ```php
  $mock->method('methodName')
      ->with($this->equalTo('expectedArg'))
      ->willReturn('mockResponse');
  ```
- Only mock what you need to control the test path
- Document mock objects with typehints and docblocks:
  ```php
  /** @var \PHPUnit\Framework\MockObject\MockObject|ClassName */
  private $mockObject;
  ```

## Test Organization

- Group related test methods within the same test class
- Use data providers for testing multiple input variations:
  ```php
  /**
   * @dataProvider provideTestCases
   */
  public function testMethod($input, $expected): void
  {
      $this->assertSame($expected, $this->subject->method($input));
  }
  
  public function provideTestCases(): array
  {
      return [
          'case description' => ['input value', 'expected result'],
          // More test cases...
      ];
  }
  ```
- Use appropriate annotations to document test coverage and organization:
  - `@covers` to specify what class/method is being tested
  - `@group` to categorize tests for selective running
  - `@dataProvider` to link data provider methods

## Assertion Best Practices

- Use specific assertions rather than generic ones:
  - Use `assertSame()` instead of `assertEquals()` for strict comparison
  - Use `assertStringContainsString()` instead of `assertContains()` for strings (PHPUnit 7.5+)
  - Use `assertCount()` instead of `assertEquals(count($x), $y)`
- Include descriptive failure messages as the last argument to assertions
- Test both positive and negative cases
- Test edge cases and boundaries
- For exceptions, use the modern expectException pattern:
  ```php
  $this->expectException(ExceptionClass::class);
  $this->expectExceptionMessage('Expected message');
  $subject->methodThatThrows();
  ```

## Examples

<example type="valid">
<?php

namespace Lpp\Product\Tests\Unit;

use PHPUnit\Framework\TestCase;
use Lpp\Product\ProductService;
use Lpp\Product\Repository\ProductRepositoryInterface;
use Lpp\Product\Exception\ProductNotFoundException;

/**
 * @covers \Lpp\Product\ProductService
 */
class ProductServiceTest extends TestCase
{
    /**
     * @var ProductService
     */
    private $subject;
    
    /**
     * @var ProductRepositoryInterface|\PHPUnit\Framework\MockObject\MockObject
     */
    private $productRepository;
    
    protected function setUp(): void
    {
        $this->productRepository = $this->createMock(ProductRepositoryInterface::class);
        $this->subject = new ProductService($this->productRepository);
    }
    
    /**
     * @test
     * @dataProvider validProductIdsProvider
     */
    public function getProductShouldReturnProductForValidId(string $productId, array $productData): void
    {
        // Arrange
        $this->productRepository->method('findById')
            ->with($this->equalTo($productId))
            ->willReturn($productData);
            
        // Act
        $result = $this->subject->getProduct($productId);
        
        // Assert
        $this->assertSame($productData, $result, "Product data should match repository data");
        $this->assertArrayHasKey('name', $result, "Product data should contain name");
    }
    
    /**
     * @test
     */
    public function getProductShouldThrowExceptionForInvalidId(): void
    {
        // Arrange
        $invalidId = 'invalid-id';
        $this->productRepository->method('findById')
            ->with($this->equalTo($invalidId))
            ->willReturn(null);
            
        // Assert expectation
        $this->expectException(ProductNotFoundException::class);
        $this->expectExceptionMessage("Product with ID {$invalidId} not found");
        
        // Act
        $this->subject->getProduct($invalidId);
    }
    
    /**
     * @return array
     */
    public function validProductIdsProvider(): array
    {
        return [
            'simple product' => [
                'product-1', 
                ['id' => 'product-1', 'name' => 'Test Product', 'price' => 19.99]
            ],
            'product with options' => [
                'product-2', 
                ['id' => 'product-2', 'name' => 'Test Product with Options', 'price' => 29.99, 'options' => ['color' => 'blue']]
            ],
        ];
    }
    
    protected function tearDown(): void
    {
        $this->subject = null;
        $this->productRepository = null;
    }
}
</example>

<example type="invalid">
<?php
// Missing or incorrect namespace
class SomeProductTest extends PHPUnit_Framework_TestCase // Outdated base class
{
    // Missing typed properties
    private $service;
    private $repo;
    
    // Missing return type
    public function setUp() 
    {
        // No clear mocking strategy, using real objects
        $this->repo = new ProductRepository();
        $this->service = new ProductService($this->repo);
    }
    
    // Missing test prefix and unclear method name
    public function productGetWorking()
    {
        // No clear Arrange-Act-Assert pattern
        $product = $this->service->getProduct("123");
        $this->assertTrue(is_array($product)); // Generic assertion
        $this->assertTrue(isset($product["name"])); // Multiple assertions without clear purpose
    }
    
    // Mixed test and helper methods
    public function getSampleData()
    {
        return ["id" => "123", "name" => "Test"]; 
    }
    
    // Old style exception testing
    public function testException()
    {
        try {
            $this->service->getProduct("invalid");
            $this->fail("Should have thrown exception");
        } catch (Exception $e) {
            $this->assertTrue(true); // Meaningless assertion
        }
    }
    
    // No tearDown method
}
</example>

## Testing Database Interactions

When testing database interactions, consider the following best practices:

- Use an in-memory database for tests when possible
- Use transactions to roll back changes after tests
- Isolate the database layer with proper abstractions
- Use specific database-oriented assertions when applicable
- Consider using a separate test database with known state

## Specific PHP/PHPUnit Version Features

### For PHP 7.2+ (Your project's minimum version)
- Use the null coalescing operator (`??`)
- Use scalar type hints and return types
- Use the array spread operator

### For PHPUnit 6.x (Your project's version)
- Use namespaced class names (\PHPUnit\Framework\TestCase)
- Use expectException() instead of setExpectedException()
- Use createMock() instead of getMock()
- Use annotations like @covers, @dataProvider, etc.
- Properly typehint mock objects

## Test Suite Organization

- Place tests in a parallel directory structure to the code being tested
- Use consistent file naming (e.g., ClassNameTest.php)
- Group tests into appropriate suites using XML configuration or annotations
- Separate unit tests from integration and functional tests